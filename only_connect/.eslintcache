[{"/Users/alexkats/Documents/Only_Connect/only_connect/src/index.js":"1","/Users/alexkats/Documents/Only_Connect/only_connect/src/reportWebVitals.js":"2","/Users/alexkats/Documents/Only_Connect/only_connect/src/App.js":"3","/Users/alexkats/Documents/Only_Connect/only_connect/src/Components/PSWall.js":"4","/Users/alexkats/Documents/Only_Connect/only_connect/src/Components/MissingVowels.js":"5","/Users/alexkats/Documents/Only_Connect/only_connect/src/Components/WordWall.js":"6","/Users/alexkats/Documents/Only_Connect/only_connect/src/Components/Rectangle.js":"7","/Users/alexkats/Documents/Only_Connect/only_connect/src/Components/WallIcon.js":"8","/Users/alexkats/Documents/Only_Connect/only_connect/src/Components/Game.js":"9","/Users/alexkats/Documents/Only_Connect/only_connect/src/utilities/helpersWordWall.js":"10","/Users/alexkats/Documents/Only_Connect/only_connect/src/Components/PSRow.js":"11"},{"size":503,"mtime":1608086169321,"results":"12","hashOfConfig":"13"},{"size":362,"mtime":1608086169321,"results":"14","hashOfConfig":"13"},{"size":232,"mtime":1612230244742,"results":"15","hashOfConfig":"13"},{"size":1680,"mtime":1612230244744,"results":"16","hashOfConfig":"13"},{"size":452,"mtime":1612230244744,"results":"17","hashOfConfig":"13"},{"size":7009,"mtime":1612230244746,"results":"18","hashOfConfig":"13"},{"size":2017,"mtime":1612230265335,"results":"19","hashOfConfig":"13"},{"size":391,"mtime":1612230244746,"results":"20","hashOfConfig":"13"},{"size":1268,"mtime":1612230244743,"results":"21","hashOfConfig":"13"},{"size":1945,"mtime":1609739041880,"results":"22","hashOfConfig":"13"},{"size":1516,"mtime":1612230244744,"results":"23","hashOfConfig":"13"},{"filePath":"24","messages":"25","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"26"},"1fajw7o",{"filePath":"27","messages":"28","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"26"},{"filePath":"29","messages":"30","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"31","messages":"32","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"26"},{"filePath":"33","messages":"34","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"26"},{"filePath":"35","messages":"36","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"37","usedDeprecatedRules":"26"},{"filePath":"38","messages":"39","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"40","messages":"41","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"26"},{"filePath":"42","messages":"43","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"26"},{"filePath":"44","messages":"45","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"46","usedDeprecatedRules":"26"},{"filePath":"47","messages":"48","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},"/Users/alexkats/Documents/Only_Connect/only_connect/src/index.js",[],["49","50"],"/Users/alexkats/Documents/Only_Connect/only_connect/src/reportWebVitals.js",[],"/Users/alexkats/Documents/Only_Connect/only_connect/src/App.js",[],"/Users/alexkats/Documents/Only_Connect/only_connect/src/Components/PSWall.js",[],"/Users/alexkats/Documents/Only_Connect/only_connect/src/Components/MissingVowels.js",[],"/Users/alexkats/Documents/Only_Connect/only_connect/src/Components/WordWall.js",["51","52","53"],"import React, { createRef, Component } from \"react\";\nimport Rectangle from \"./Rectangle\";\nimport { v4 as uuidv4 } from \"uuid\";\nimport { clearClickedList, checkForMatch, animate, randomize } from \"../utilities/helpersWordWall\";\nimport Button from \"@material-ui/core/Button\";\nimport \"./WordWall.css\";\n\nconst colorDictionary = {\n    0: \"bg-red-500\",\n    1: \"bg-blue-500\",\n    2: \"bg-green-500\",\n    3: \"bg-yellow-500\",\n};\nconst wordDictionary = [\n    [\"Hazelnut\", \"Butter Pecan\", \"Coconut\", \"Caramel\"],\n    [\"Cube\", \"Vanilla\", \"T\", \"Prince\"],\n    [\"Australia\", \"Guam\", \"Papua New Guinea\", \"Cook Islands\"],\n    [\"Champagne\", \"San Pellegrino\", \"Fiji\", \"Mocha\"],\n];\n\nclass WordWall extends Component {\n    constructor() {\n        super();\n        this.idToIndex = new Map();\n        this.refsArr = [];\n        this.state = {\n            clicked: [],\n            color_count: 0,\n            solved: [],\n        };\n        this.handleClickBlock = this.handleClickBlock.bind(this);\n        this.solveBoard = this.solveBoard.bind(this);\n    }\n\n    componentDidMount() {\n        let blocks = [];\n        for (let [index, group] of wordDictionary.entries()) {\n            let words = group.map((word) => {\n                this.refsArr.push(createRef());\n                return {\n                    word: word,\n                    color: \"bg-oc-blue\",\n                    id: uuidv4(),\n                    group: index,\n                    clicked: false,\n                    matched: false,\n                };\n            });\n            blocks.push(...words);\n        }\n        blocks = randomize(blocks);\n        for (let [index, block] of blocks.entries()) {\n            this.idToIndex.set(block.id, index);\n        }\n        this.setState({ solved: blocks });\n    }\n\n    handleClickBlock(obj) {\n        if (this.state.clicked.length < 4) {\n            if (obj.clicked) {\n                this.unClickBlock(obj);\n            } else {\n                this.clickBlock(obj);\n            }\n        }\n    }\n\n    clickBlock(obj) {\n        const clickedList = [...this.state.clicked],\n            solvedList = [...this.state.solved];\n        let delay = 0,\n            count = this.state.color_count;\n        clickedList.push(obj);\n        const foundIndex = this.idToIndex.get(obj.id);\n        solvedList[foundIndex].clicked = true;\n        solvedList[foundIndex].color = colorDictionary[count];\n        this.setState({ solved: solvedList, clicked: clickedList }, () => {\n            if (clickedList.length === 4) {\n                this.fourthBlockClicked();\n            }\n        });\n    }\n\n    fourthBlockClicked() {\n        let delay = 0,\n            count = this.state.color_count;\n        const clickedList = [...this.state.clicked];\n        const solvedList = [...this.state.solved];\n        const areOfSameGroup = checkForMatch(clickedList);\n        if (areOfSameGroup) {\n            if (count == 2) {\n                this.solveBoard();\n                return;\n            } else {\n                this.matchRow(clickedList, solvedList, count);\n                count++;\n            }\n        } else {\n            clearClickedList(clickedList, solvedList, this.idToIndex);\n            delay = 250;\n        }\n        clickedList.length = 0;\n        setTimeout(() => {\n            this.setState({\n                solved: solvedList,\n                clicked: clickedList,\n                color_count: count,\n            });\n        }, delay);\n    }\n\n    unClickBlock(obj) {\n        let clickedList = [...this.state.clicked],\n            solvedList = [...this.state.solved];\n        clickedList = clickedList.filter((word) => {\n            return word.id !== obj.id;\n        });\n        let unclickIndex = this.idToIndex.get(obj.id);\n        solvedList[unclickIndex].color = \"bg-oc-blue\";\n        solvedList[unclickIndex].clicked = false;\n        this.setState({ solved: solvedList, clicked: clickedList });\n    }\n\n    matchRow(clickedList, solvedList, count) {\n        const eltBoundsBefore = this.refsArr.map((el) => {\n            return el.current.getBoundingClientRect();\n        });\n        const arr = [...this.refsArr];\n        for (let block of clickedList) {\n            const foundIndex = solvedList.findIndex((word) => word.id == block.id);\n            solvedList[foundIndex].matched = true;\n            const removedVal = solvedList.splice(foundIndex, 1);\n            const removedRef = this.refsArr.splice(foundIndex, 1);\n            solvedList.splice(count * 4, 0, ...removedVal);\n            this.refsArr.splice(count * 4, 0, ...removedRef);\n        }\n        this.setState({ solved: solvedList }, () => {\n            animate(arr, eltBoundsBefore);\n            for (let [index, block] of solvedList.entries()) {\n                this.idToIndex.set(block.id, index);\n            }\n        });\n    }\n\n    solveBoard() {\n        const solvedList = [...this.state.solved];\n        const color = this.state.color_count;\n        const nodeToRef = new Map();\n        const eltBoundsBefore = this.refsArr.map((el) => {\n            return el.current.getBoundingClientRect();\n        });\n        let arr = [...this.refsArr];\n        const matchedIndex = solvedList.findIndex((el) => !el.matched);\n\n        solvedList.forEach((block, index) => {\n            nodeToRef.set(block.id, this.refsArr[index]);\n        });\n        const length = solvedList.length;\n        const toBeMatched = solvedList.splice(matchedIndex, length - matchedIndex);\n        this.refsArr.splice(matchedIndex, length - matchedIndex);\n\n        toBeMatched.sort((a, b) => a.group - b.group);\n        toBeMatched.forEach((block, index) => {\n            block.matched = true;\n            block.clicked = true;\n            block.color = colorDictionary[color + Math.floor(index / 4)];\n            solvedList.push(block);\n            this.refsArr.push(nodeToRef.get(block.id));\n        });\n        this.setState({ solved: solvedList }, () => {\n            animate(arr, eltBoundsBefore);\n        });\n    }\n\n    buildBoard() {\n        return this.state.solved.map((block, index) => {\n            return (\n                <Rectangle\n                    ref={this.refsArr[index]}\n                    key={block.id}\n                    type=\"wall\"\n                    {...block}\n                    clickBlock={this.handleClickBlock}\n                >\n                    {block.word}\n                </Rectangle>\n            );\n        });\n    }\n\n    render() {\n        return (\n            <div style={{ display: \"flex\", flexDirection: \"column\", placeItems: \"center\" }}>\n                <h1 style={{ textAlign: \"center\" }}>Word Wall</h1>\n                <div className=\"grid justify-center items-center\">{this.buildBoard()}</div>\n                <Button\n                    style={{ width: \"50%\" }}\n                    variant=\"contained\"\n                    color=\"primary\"\n                    onClick={this.solveBoard}\n                >\n                    Solve\n                </Button>\n            </div>\n        );\n    }\n}\nexport default WordWall;\n","/Users/alexkats/Documents/Only_Connect/only_connect/src/Components/Rectangle.js",["54","55","56"],"/Users/alexkats/Documents/Only_Connect/only_connect/src/Components/WallIcon.js",[],"/Users/alexkats/Documents/Only_Connect/only_connect/src/Components/Game.js",[],"/Users/alexkats/Documents/Only_Connect/only_connect/src/utilities/helpersWordWall.js",["57","58","59"],"export function randomize(arr) {\n    let random = [];\n    let val = 0;\n    while (arr.length) {\n        let index = Math.floor(Math.random() * arr.length);\n        val = arr.splice(index, 1);\n        random.push(...val);\n    }\n    return random;\n}\n\nexport function animate(arr, eltBoundsBefore, color) {\n    const eltBoundsAfter = arr.map((el) => {\n        return el.current.getBoundingClientRect();\n    });\n\n    arr.forEach((item, index) => {\n        const deltaX = eltBoundsBefore[index].left - eltBoundsAfter[index].left;\n        const deltaY = eltBoundsBefore[index].top - eltBoundsAfter[index].top;\n        const deltaW = eltBoundsBefore[index].width / eltBoundsAfter[index].width;\n        const deltaH = eltBoundsBefore[index].height / eltBoundsAfter[index].height;\n\n        item.current.animate(\n            [\n                {\n                    transformOrigin: \"top left\",\n                    transform: `\n                  translate(${deltaX}px, ${deltaY}px)\n                  scale(${deltaW}, ${deltaH})\n                `,\n                },\n                {\n                    transformOrigin: \"top left\",\n                    transform: `\n                translate(${0}px, ${0}px)\n                scale(${deltaW}, ${deltaH})\n              `,\n                },\n            ],\n            {\n                duration: 1000,\n                easing: \"ease-in-out\",\n                fill: \"both\",\n            },\n        );\n    });\n}\n\nexport function checkForMatch(clickedList) {\n    return (\n        clickedList[0].group == clickedList[1].group &&\n        clickedList[0].group == clickedList[2].group &&\n        clickedList[0].group == clickedList[3].group\n    );\n}\n\nexport function clearClickedList(clickedList, solvedList, idToIndex) {\n    for (let block of clickedList) {\n        let foundIndex = idToIndex.get(block.id);\n        solvedList[foundIndex].clicked = false;\n        solvedList[foundIndex].color = \" bg-oc-blue\";\n    }\n}\n","/Users/alexkats/Documents/Only_Connect/only_connect/src/Components/PSRow.js",["60","61","62"],{"ruleId":"63","replacedBy":"64"},{"ruleId":"65","replacedBy":"66"},{"ruleId":"67","severity":1,"message":"68","line":71,"column":13,"nodeType":"69","messageId":"70","endLine":71,"endColumn":18},{"ruleId":"71","severity":1,"message":"72","line":91,"column":23,"nodeType":"73","messageId":"74","endLine":91,"endColumn":25},{"ruleId":"71","severity":1,"message":"72","line":130,"column":71,"nodeType":"73","messageId":"74","endLine":130,"endColumn":73},{"ruleId":"67","severity":1,"message":"75","line":1,"column":17,"nodeType":"69","messageId":"70","endLine":1,"endColumn":28},{"ruleId":"67","severity":1,"message":"76","line":1,"column":30,"nodeType":"69","messageId":"70","endLine":1,"endColumn":36},{"ruleId":"67","severity":1,"message":"77","line":1,"column":38,"nodeType":"69","messageId":"70","endLine":1,"endColumn":47},{"ruleId":"71","severity":1,"message":"72","line":51,"column":30,"nodeType":"73","messageId":"74","endLine":51,"endColumn":32},{"ruleId":"71","severity":1,"message":"72","line":52,"column":30,"nodeType":"73","messageId":"74","endLine":52,"endColumn":32},{"ruleId":"71","severity":1,"message":"72","line":53,"column":30,"nodeType":"73","messageId":"74","endLine":53,"endColumn":32},{"ruleId":"67","severity":1,"message":"77","line":1,"column":27,"nodeType":"69","messageId":"70","endLine":1,"endColumn":36},{"ruleId":"67","severity":1,"message":"78","line":8,"column":11,"nodeType":"69","messageId":"70","endLine":8,"endColumn":28},{"ruleId":"71","severity":1,"message":"72","line":13,"column":18,"nodeType":"73","messageId":"74","endLine":13,"endColumn":20},"no-native-reassign",["79"],"no-negated-in-lhs",["80"],"no-unused-vars","'delay' is assigned a value but never used.","Identifier","unusedVar","eqeqeq","Expected '===' and instead saw '=='.","BinaryExpression","unexpected","'useCallback' is defined but never used.","'useRef' is defined but never used.","'useEffect' is defined but never used.","'hidden_dictionary' is assigned a value but never used.","no-global-assign","no-unsafe-negation"]